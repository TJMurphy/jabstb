[
["rnaseq.html", "Chapter 47 RNA-seq with R 47.1 Install Bioconductor 47.2 Import raw count data 47.3 Munge to simpler table 47.4 Filtering 47.5 DGEList 47.6 Visualization 47.7 Classification 47.8 Hierarchical clustering 47.9 Summary", " Chapter 47 RNA-seq with R library(tidyverse) library(edgeR) library(limma) library(gplots) library(viridis) This example is adopted extensively from RNA-seq analysis in R by Belinda Phips and colleagues. The data are available here and here. These are part of a broader workship presented by the group with very easy to follow protocols for RNA-seq analysis with R. The data below are from a study of mammary gland development showing the pro-survival gene Mcl1 as a master regulator gland development. They represent duplicate RNA-seq measurements from each of 6 groups: basal and luminal cells from virgin, pregnant and lactating mice. The purpose of having this in JABSTB at this stage is to offer a gentle introduction to RNA-seq data and analysis. The focus here is on the classification methods within this example. 47.1 Install Bioconductor This chapter uses functions in Bioconductor. Bioconductor is a universe of packages and functions geared for bio/omics data analysis. It is managed separately from the broader CRAN universe. As for the CRAN universe, we don’t automagically have the full universe of Bioconductor packages by default. We just get a working base suite. If we want more, we have to find it and install it. The most important difference is to use the Bioconductor package manager to install packages. When we want to install additional Bioconductor packages we would do so this way, BiocManager::install(\"newthing\"), not this way, install.packages(\"newthing\") Go to that link and read more about Bioconductor. Then install Bioconductor by running the script below in your console. There is much to install. This will take a while. Do NOT compile anything If you see the prompt below, always choose no: Do you want to install from sources the package which needs compilation (yes/no/cancel)? if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(version = &quot;3.10&quot;) 47.2 Import raw count data By this point, there has already been considerable processing of the sequence data. Sequences have been matched to their genes and to each other. The values in this table are counts of the number of transcript reads per gene, in each of the 12 samples. Read them into an object. seqdata &lt;- read.delim(&quot;datasets/GSE60450_Lactation-GenewiseCounts.txt&quot;) head(seqdata) ## EntrezGeneID Length MCL1.DG_BC2CTUACXX_ACTTGA_L002_R1 ## 1 497097 3634 438 ## 2 100503874 3259 1 ## 3 100038431 1634 0 ## 4 19888 9747 1 ## 5 20671 3130 106 ## 6 27395 4203 309 ## MCL1.DH_BC2CTUACXX_CAGATC_L002_R1 MCL1.DI_BC2CTUACXX_ACAGTG_L002_R1 ## 1 300 65 ## 2 0 1 ## 3 0 0 ## 4 1 0 ## 5 182 82 ## 6 234 337 ## MCL1.DJ_BC2CTUACXX_CGATGT_L002_R1 MCL1.DK_BC2CTUACXX_TTAGGC_L002_R1 ## 1 237 354 ## 2 1 0 ## 3 0 0 ## 4 0 0 ## 5 105 43 ## 6 300 290 ## MCL1.DL_BC2CTUACXX_ATCACG_L002_R1 MCL1.LA_BC2CTUACXX_GATCAG_L001_R1 ## 1 287 0 ## 2 4 0 ## 3 0 0 ## 4 0 10 ## 5 82 16 ## 6 270 560 ## MCL1.LB_BC2CTUACXX_TGACCA_L001_R1 MCL1.LC_BC2CTUACXX_GCCAAT_L001_R1 ## 1 0 0 ## 2 0 0 ## 3 0 0 ## 4 3 10 ## 5 25 18 ## 6 464 489 ## MCL1.LD_BC2CTUACXX_GGCTAC_L001_R1 MCL1.LE_BC2CTUACXX_TAGCTT_L001_R1 ## 1 0 0 ## 2 0 0 ## 3 0 0 ## 4 2 0 ## 5 8 3 ## 6 328 307 ## MCL1.LF_BC2CTUACXX_CTTGTA_L001_R1 ## 1 0 ## 2 0 ## 3 0 ## 4 0 ## 5 10 ## 6 342 To see the data set’s dimensions. dim(seqdata) ## [1] 27179 14 There are 14 columns and over 27000 rows. The information about the sample will be used later. Read it into the environment now. sampleinfo &lt;- read.delim(&quot;datasets/SampleInfo_Corrected.txt&quot;) sampleinfo ## FileName SampleName CellType Status ## 1 MCL1.DG_BC2CTUACXX_ACTTGA_L002_R1 MCL1.DG basal virgin ## 2 MCL1.DH_BC2CTUACXX_CAGATC_L002_R1 MCL1.DH basal virgin ## 3 MCL1.DI_BC2CTUACXX_ACAGTG_L002_R1 MCL1.DI basal pregnant ## 4 MCL1.DJ_BC2CTUACXX_CGATGT_L002_R1 MCL1.DJ basal pregnant ## 5 MCL1.DK_BC2CTUACXX_TTAGGC_L002_R1 MCL1.DK basal lactate ## 6 MCL1.DL_BC2CTUACXX_ATCACG_L002_R1 MCL1.DL basal lactate ## 7 MCL1.LA_BC2CTUACXX_GATCAG_L001_R1 MCL1.LA luminal virgin ## 8 MCL1.LB_BC2CTUACXX_TGACCA_L001_R1 MCL1.LB luminal virgin ## 9 MCL1.LC_BC2CTUACXX_GCCAAT_L001_R1 MCL1.LC luminal pregnant ## 10 MCL1.LD_BC2CTUACXX_GGCTAC_L001_R1 MCL1.LD luminal pregnant ## 11 MCL1.LE_BC2CTUACXX_TAGCTT_L001_R1 MCL1.LE luminal lactate ## 12 MCL1.LF_BC2CTUACXX_CTTGTA_L001_R1 MCL1.LF luminal lactate 47.3 Munge to simpler table Create a table that has only count data so that we can do several manipulations of the gene expression data. countdata &lt;- select(seqdata, -EntrezGeneID, -Length) countdata &lt;- as.data.frame(countdata) Note below how the EntrezGeneID is placed back in as row names. The row names are not a variable. rownames(countdata) &lt;- seqdata[,1] This is a data frame now with row and column names. Each column corresponds to a biological replicate, each row a gene id. Every cell in a row is the raw transcript counts for that gene under that replicate condition. Shorten the column names. They start with 7 non-identical characters which are good identifiers. colnames(countdata) &lt;- substring(colnames(countdata), 1,7) head(countdata) ## MCL1.DG MCL1.DH MCL1.DI MCL1.DJ MCL1.DK MCL1.DL MCL1.LA MCL1.LB ## 497097 438 300 65 237 354 287 0 0 ## 100503874 1 0 1 1 0 4 0 0 ## 100038431 0 0 0 0 0 0 0 0 ## 19888 1 1 0 0 0 0 10 3 ## 20671 106 182 82 105 43 82 16 25 ## 27395 309 234 337 300 290 270 560 464 ## MCL1.LC MCL1.LD MCL1.LE MCL1.LF ## 497097 0 0 0 0 ## 100503874 0 0 0 0 ## 100038431 0 0 0 0 ## 19888 10 2 0 0 ## 20671 18 8 3 10 ## 27395 489 328 307 342 Now we’re in pretty good shape in terms of having a simple view of the raw count data. 47.4 Filtering Next we need to filter out the genes for which there are no reads, or there are inconsistent reads across replicate samples, or there are low reads. This is a multistep process. The first step is to choose a normalization technique. RPKM (reads per kilo base per million) and CPM (counts per million) are common options. We’ll use the latter. Our filtering rule is to keep transcripts that have CPM &gt; 0.5 in at least two samples. A CPM of 0.5 corresponds to roughly 10-15 counts per gene in this sized library. This threshold decision is a scientific judgement based upon one’s experience regarding the sensitivity of the count measurement. Thresholds of 1 or 2 CPM are not uncommon. First, convert raw counts to CPM. myCPM &lt;- edgeR::cpm(countdata) head(myCPM) ## MCL1.DG MCL1.DH MCL1.DI MCL1.DJ MCL1.DK MCL1.DL ## 497097 18.85684388 13.77543859 2.69700983 10.45648006 16.442685 14.3389690 ## 100503874 0.04305215 0.00000000 0.04149246 0.04412017 0.000000 0.1998463 ## 100038431 0.00000000 0.00000000 0.00000000 0.00000000 0.000000 0.0000000 ## 19888 0.04305215 0.04591813 0.00000000 0.00000000 0.000000 0.0000000 ## 20671 4.56352843 8.35709941 3.40238163 4.63261775 1.997275 4.0968483 ## 27395 13.30311589 10.74484210 13.98295863 13.23605071 13.469996 13.4896224 ## MCL1.LA MCL1.LB MCL1.LC MCL1.LD MCL1.LE MCL1.LF ## 497097 0.0000000 0.0000000 0.0000000 0.00000000 0.0000000 0.0000000 ## 100503874 0.0000000 0.0000000 0.0000000 0.00000000 0.0000000 0.0000000 ## 100038431 0.0000000 0.0000000 0.0000000 0.00000000 0.0000000 0.0000000 ## 19888 0.4903857 0.1381969 0.4496078 0.09095771 0.0000000 0.0000000 ## 20671 0.7846171 1.1516411 0.8092940 0.36383085 0.1213404 0.4055595 ## 27395 27.4615975 21.3744588 21.9858214 14.91706476 12.4171715 13.8701357 Next, impose the threshold. First, this script is a simple logical that identifies genes and groups that satisfy the first part of the filtering rule. thresh &lt;- myCPM &gt; 0.5 head(thresh) ## MCL1.DG MCL1.DH MCL1.DI MCL1.DJ MCL1.DK MCL1.DL MCL1.LA MCL1.LB ## 497097 TRUE TRUE TRUE TRUE TRUE TRUE FALSE FALSE ## 100503874 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## 100038431 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## 19888 FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## 20671 TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## 27395 TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## MCL1.LC MCL1.LD MCL1.LE MCL1.LF ## 497097 FALSE FALSE FALSE FALSE ## 100503874 FALSE FALSE FALSE FALSE ## 100038431 FALSE FALSE FALSE FALSE ## 19888 FALSE FALSE FALSE FALSE ## 20671 TRUE FALSE FALSE FALSE ## 27395 TRUE TRUE TRUE TRUE Here’s a summary of that result. table(rowSums(thresh)) ## ## 0 1 2 3 4 5 6 7 8 9 10 11 12 ## 10857 518 544 307 346 307 652 323 547 343 579 423 11433 There are 10857 genes that are \\(\\le 0.5\\) CPM in all twelve samples. There are 518 genes that have greater than 0.5 CPM in only 1 sample. 544 genes have greater than 0.5 CPM in only two samples, 307 genes with greater than 0.5 CPM in 3 samples, and so on. There are 11433 genes which have greater than 0.5 CPM in all twelve samples. Second, identify the genes for which the second condition above is satisfied. This is another logical. And it just creates a long logical vector, with a True or False corresponding to each row name. keep &lt;- rowSums(thresh) &gt;= 2 summary(keep) ## Mode FALSE TRUE ## logical 11375 15804 Thus, there are 15804 genes which have greater than 0.5 CPM in at least two samples. Here is an updated counts dataset containing only those genes that are filtered. This is the final filtered dataset which will be used for the statistical analysis. # Subset the rows of countdata to keep the more highly expressed genes counts.keep &lt;- countdata[keep,] head(counts.keep) ## MCL1.DG MCL1.DH MCL1.DI MCL1.DJ MCL1.DK MCL1.DL MCL1.LA MCL1.LB MCL1.LC ## 497097 438 300 65 237 354 287 0 0 0 ## 20671 106 182 82 105 43 82 16 25 18 ## 27395 309 234 337 300 290 270 560 464 489 ## 18777 652 515 948 935 928 791 826 862 668 ## 21399 1604 1495 1721 1317 1159 1066 1334 1258 1068 ## 58175 4 2 14 4 2 2 170 165 138 ## MCL1.LD MCL1.LE MCL1.LF ## 497097 0 0 0 ## 20671 8 3 10 ## 27395 328 307 342 ## 18777 646 544 581 ## 21399 926 508 500 ## 58175 60 27 15 woot! 47.5 DGEList The counts.keep dataframe is converted into a list object for ease of analysis moving forward. It will be passed into other functions within the Bioconductor universe. y &lt;- edgeR::DGEList(counts.keep) y ## An object of class &quot;DGEList&quot; ## $counts ## MCL1.DG MCL1.DH MCL1.DI MCL1.DJ MCL1.DK MCL1.DL MCL1.LA MCL1.LB MCL1.LC ## 497097 438 300 65 237 354 287 0 0 0 ## 20671 106 182 82 105 43 82 16 25 18 ## 27395 309 234 337 300 290 270 560 464 489 ## 18777 652 515 948 935 928 791 826 862 668 ## 21399 1604 1495 1721 1317 1159 1066 1334 1258 1068 ## MCL1.LD MCL1.LE MCL1.LF ## 497097 0 0 0 ## 20671 8 3 10 ## 27395 328 307 342 ## 18777 646 544 581 ## 21399 926 508 500 ## 15799 more rows ... ## ## $samples ## group lib.size norm.factors ## MCL1.DG 1 23218026 1 ## MCL1.DH 1 21768136 1 ## MCL1.DI 1 24091588 1 ## MCL1.DJ 1 22656713 1 ## MCL1.DK 1 21522033 1 ## 7 more rows ... 47.6 Visualization A lot of the -omic visualizations use the plotting functions of R base. It is fairly easy to get something in the box with these plotting functions, but a bit more difficult to get them gussied up all nice and pretty. Comparing library sizes checks for any anomalies. There are none. Each sample library size is about the same. barplot(y$samples$lib.size,names=colnames(y),las=2) # Add a title to the plot title(&quot;Comparison of library sizes&quot;) Figure 47.1: Sizes of RNAseq libraries for each sample. Here’s a plot of the raw counts, in order to illustrate they are not normally-distributed, which is typical of discrete count data. boxplot(y$counts, las=2) Figure 47.2: Distribution of counts across the 12 samples. Note they are not normally-distributed. Here’s a plot of the CPM, which is also not normally distributed. This illustrates that CPM is just a simple linear transform of count data. boxplot(cpm(y$counts), las=2) Figure 47.3: Distribution of CPM-transformed counts, still not normally-distributed. Here’s a plot of a log transformation of CPM data. This transformation yields an approximately Gaussian distribution of the count values within each sample, though there are clearly outliers. The log transformed CPM data will be used in a lot of the statistical analysis because of this Gaussian property. So we’ll go ahead and make an object for that. # Get log2 counts per million logcounts &lt;- cpm(y,log=TRUE) Now look at the logcount date by plotting box plots. # Check distributions of samples using boxplots boxplot(logcounts, xlab=&quot;&quot;, ylab=&quot;Log2 counts per million&quot;,las=2) # Let&#39;s add a blue horizontal line that corresponds to the median logCPM abline(h=median(logcounts),col=&quot;blue&quot;) title(&quot;Boxplots of logCPMs (unnormalised)&quot;) Figure 47.4: Natural log transformed CPM counts, normally-distributed but some outliers. 47.7 Classification Multidimensional scaling is a cousin of principal component analysis. It provides a simple way to see if sample groups separate along their first and second dimensions. This is based upon a leading fold-change metric. This examines the subset of genes that exhibit the largest fold-differences between samples. The graph below shows separation and clustering of the 12 samples, but it is a bit hard to see what is what unless you’ve remembered what each sample represents. limma::plotMDS(y) Figure 47.5: Multi-dimensional scaling, a form of PCA. We’ll munge out some better plots below, focusing on the the classification of the predictor variables. Recall there are 12 samples, duplicates of gene expression in basal and luminal cells, for each of the following three conditions: the cells were derived from mice that were virgin, pregnant, or lactating. First we’ll color by the feature that involves basal and luminal. # Let&#39;s set up colour schemes for CellType # How many cell types and in what order are they stored? levels(sampleinfo$CellType) ## [1] &quot;basal&quot; &quot;luminal&quot; col.cell &lt;- c(&quot;#012169&quot;,&quot;#b58500&quot;)[sampleinfo$CellType] data.frame(sampleinfo$CellType,col.cell) ## sampleinfo.CellType col.cell ## 1 basal #012169 ## 2 basal #012169 ## 3 basal #012169 ## 4 basal #012169 ## 5 basal #012169 ## 6 basal #012169 ## 7 luminal #b58500 ## 8 luminal #b58500 ## 9 luminal #b58500 ## 10 luminal #b58500 ## 11 luminal #b58500 ## 12 luminal #b58500 The plot below clearly illustrates that the basal/luminal feature represents the first dimension of separation between the samples. In other words, the differences between basal and luminal cell gene expression accounts for most of the variation in the set. # Redo the MDS with cell type colouring plotMDS(y,col=col.cell) # Let&#39;s add a legend to the plot so we know which colours correspond to which cell type legend(&quot;topleft&quot;, fill=c(&quot;#012169&quot;,&quot;#b58500&quot;),legend=levels(sampleinfo$CellType)) # Add a title title(&quot;Cell type&quot;) Figure 47.6: MDS shows variation due to cell type explains the first dimension of the data. We’ll do the same coloring trick for status. col.status &lt;- c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;)[sampleinfo$Status] col.status ## [1] &quot;green&quot; &quot;green&quot; &quot;blue&quot; &quot;blue&quot; &quot;red&quot; &quot;red&quot; &quot;green&quot; &quot;green&quot; &quot;blue&quot; ## [10] &quot;blue&quot; &quot;red&quot; &quot;red&quot; The plot below colors each sample on the basis of whether it is from a virgin, pregnant, or lactating mouse. There is some separation of them along the 2nd dimension. Note how the duplicates of the same condition are very similar (the MCL1.DL lactating sample is missing for some reason?) plotMDS(y,col=col.status) legend(&quot;topleft&quot;,fill=c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;), legend=levels(sampleinfo$Status),cex=0.8) title(&quot;Status&quot;) Figure 47.7: Variation due to status represents the 2nd dimension of the data set. Thus, although these dimensions are latent, it is often possible to explain what variables are most responsible for the observed variation, and thus explain the first two principal components. The Bioconductor package PCAtoolsis a veritable smorgasbord of PCA functions and visualizations. Learning this package is strongly recommended. For more on it, see this vignette 47.8 Hierarchical clustering Hierarchical clustering is a way to cluster while visualizing relationships to other clusters. Before illustrating this technique some processing is in order. We’re interested in seeing the genes driving the dimensional pattern seen above. What genes differ between the two cell types? What genes differ between the 3 status conditions? Is there an interaction between cell type and status? We can assume the most useful approach to answer this would be to focus on the genes that have the highest expression variance across the 12 samples. Rather than cluster all 15000+ genes, we’ll cluster the 500 that are most variable. This is an arbitrary cutoff. This script creates a vector of variances with associated with each GeneID. Just like in ANOVA, when row variances are high, differences in grouping factors will be greatest. var_genes &lt;- apply(logcounts, 1, var) head(var_genes) ## 497097 20671 27395 18777 21399 58175 ## 13.6624115 2.7493077 0.1581944 0.1306781 0.3929526 4.8232522 Now produce a vector with the GeneID names for those that have the greatest to lower variances, up to the 500th. # Get the gene names for the top 500 most variable genes select_var &lt;- names(sort(var_genes, decreasing=TRUE))[1:500] head(select_var) ## [1] &quot;22373&quot; &quot;12797&quot; &quot;11475&quot; &quot;11468&quot; &quot;14663&quot; &quot;24117&quot; For your information, here is the expression pattern for the GeneID “22373” with the greatest variance. It encodes Wap, a known regulator of mammary epithelium. There is much lower expression in virgin basal cells compared to the others. logcounts[&quot;22373&quot;,] ## MCL1.DG MCL1.DH MCL1.DI MCL1.DJ MCL1.DK MCL1.DL MCL1.LA ## 0.4660671 0.9113837 7.4350797 7.8078998 9.2883180 9.3184826 6.6277452 ## MCL1.LB MCL1.LC MCL1.LD MCL1.LE MCL1.LF ## 6.6884102 12.1273320 13.1502579 15.6481000 15.5696858 From logcounts we select the rows corresponding to these 500 most variable genes. # Subset logcounts matrix highly_variable_lcpm &lt;- logcounts[select_var,] dim(highly_variable_lcpm) ## [1] 500 12 head(highly_variable_lcpm) ## MCL1.DG MCL1.DH MCL1.DI MCL1.DJ MCL1.DK MCL1.DL MCL1.LA ## 22373 0.4660671 0.9113837 7.435080 7.807900 9.288318 9.318483 6.6277452 ## 12797 10.0429713 9.6977966 11.046567 11.358857 11.605894 11.491773 0.8529774 ## 11475 12.3849005 12.3247093 13.989573 14.180048 14.285489 14.032486 3.4823396 ## 11468 7.1537287 6.8917703 9.325436 9.661942 9.491765 9.424803 -1.8086076 ## 14663 1.9717614 1.9471846 9.091895 8.756261 9.539747 9.504098 6.1710357 ## 24117 7.8378853 7.8995788 8.634622 8.582447 6.704706 6.777335 -1.3824015 ## MCL1.LB MCL1.LC MCL1.LD MCL1.LE MCL1.LF ## 22373 6.6884102 12.1273320 13.1502579 15.6481000 15.569686 ## 12797 1.6034598 2.3323371 2.4601069 0.8055694 1.288003 ## 11475 4.3708241 5.2116574 5.0788442 3.6997655 3.965775 ## 11468 -0.6387584 0.5244769 0.6694047 -0.4412496 -1.014878 ## 14663 6.2328260 13.7571928 14.2506761 16.0020840 15.885390 ## 24117 -0.5387838 -0.2280797 0.1243601 -2.9468278 -2.945610 Now we simply pass this select group of the 500 most variable genes into the heatmap.2 function. The values represented here are logCPM values. # Set up colour vector for celltype variable col.cell &lt;- c(&quot;#012169&quot;,&quot;#b58500&quot;)[sampleinfo$CellType] # Plot the heatmap heatmap.2(highly_variable_lcpm, col=viridis, trace=&quot;none&quot;, main=&quot;Top 500 most variable genes across samples&quot;, ColSideColors=col.cell, scale=&quot;row&quot;) Expression varies from low (dark) to high (light). Inspection of the horizontal clustering illustrates how it picks up the the experimental design very well. There are two main groups (corresponding to the luminal (Emory gold) and basal (Emory blue) cell types). There are also 3 groups within each of these, corresponding to the status. The duplicates line up very well together. This is tight data. The vertical clustering is very interesting. Over 3 quarters of the genes define the cell type differentiation, while the rest differentiate the status (virgin, pregnant, lactating). There is a clear interaction between cell type and status, as well. 47.9 Summary This chapter is derived from an excellent workshop on using R to work with RNA-seq data. The workshop material is an excellent starting point for learning how to work with this data. I’ve only made very modest changes to a portion of this material, with the goal of making a gentle introduction and keeping a focus on classification (MDS and hierarchical clustering). Install Bioconductor to use this material. Before doing so, it is important to recognize how Bioconductor relates to R and to CRAN. I strongly recommend installing additional Bioconductor packages using the BiocManager. This workflow becomes more important when the time comes to updating, whether R or Bioconductor. The fundamental currency of RNA-seq data are transcript counts. To work with them requires transformation via normalization (such as CPM or RPKM). Counts are not normally distributed. For many statistical treatments the CPM need conversion to a Gaussian distribution. Natural log transformation usually gets this done. Scientific judgements are necessary to limit the scope of the datasets. Working with RNA-seq data demands R skills related to creating and working with a variety of on-the-fly data objects, all while keeping one’s rows and columns copacetic. "]
]
